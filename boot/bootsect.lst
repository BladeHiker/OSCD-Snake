     1                                  ; bootsect.s		(C) 1991 Linus Torvalds
     2                                  ;
     3                                  ;
     4                                  ; bootsect.s 被bios-启动子程序加载至 0x7c00 (31k)处，并将自己移到了地
     5                                  ; 址0x90000 (576k)处，并跳转至那里。 
     6                                  ;
     7                                  ; 它然后使用BIOS 中断将'setup'直接加载到自己的后面(0x90200)(576.5k)，
     8                                  ; 并将system 加载到地址0x10000 处。
     9                                  ;
    10                                  ; 注意! 目前的内核系统最大长度限制为(8*65536)(512k)字节，即使是在将来这也应该 
    11                                  ; 没有问题的。我想让它保持简单明了。这样512k 的最大内核长度应该足够了，
    12                                  ; 尤其是这里没有象 minix 中一样包含缓冲区高速缓冲。
    13                                  ;
    14                                  ; 加载程序已经做的够简单了，所以持续的读出错将导致死循环。只能手工重启。只要可能，
    15                                  ; 通过一次取取所有的扇区，加载过程可以做的很快的。
    16                                  ;
    17                                  SYSSIZE equ 0x3000					; SYS_SIZE 是要加载的节数（16 字节为1 节）。0x3000 共为0x30000 字节=
    18                                  									; 192 kB，对于当前的版本空间已足够了。
    19                                  SETUPLEN equ 4						; setup 程序的扇区数
    20                                  BOOTSEG  equ 0x07c0					; bootsect 的原始地址（是段地址，以下同）
    21                                  INITSEG  equ 0x9000					; 将bootsect 移到这里
    22                                  SETUPSEG equ 0x9020					; setup 程序从这里开始
    23                                  SYSSEG   equ 0x1000					; system 模块加载到0x10000（64 kB）处
    24                                  ENDSEG   equ SYSSEG + SYSSIZE		; 停止加载的段地址
    25                                  
    26                                  ; 根文件系统设备使用与引导时同样的软驱设备；
    27                                  ROOT_DEV equ 0x301
    28                                  
    29                                  [section .s16]
    30                                  [BITS 16]
    31                                  _start:
    32 00000000 B8C007                  	mov	ax,BOOTSEG			; 将ds 段寄存器置为0x7C0
    33 00000003 8ED8                    	mov	ds,ax
    34 00000005 B80090                  	mov	ax,INITSEG			; 将es 段寄存器置为0x9000
    35 00000008 8EC0                    	mov	es,ax
    36 0000000A B90001                  	mov	cx,256				; 移动计数值=256 字
    37 0000000D 29F6                    	sub	si,si
    38 0000000F 29FF                    	sub	di,di
    39 00000011 F3                      	rep 
    40 00000012 A5                      	movsw
    41 00000013 EA[1800]0090            	jmp	INITSEG:go			;间接跳转。这里INITSEG 指出跳转到的段地址
    42                                  	
    43                                  ; 从下面开始，CPU移动到0x90000 位置处的代码中执行。这段代码设置几个段寄存器，
    44                                  ; 包括栈寄存器ss 和sp。栈指针sp 只要指向远大于512 字节偏移（即地址 0x90200）
    45                                  ; 处都可以。 因为从0x90200 地址开始处还要放置setup 程序，而此时setup 程序大约
    46                                  ; 为4个扇区，因此sp 要指向大于（0x200 + 0x200 * 4 + 堆栈大小）处。实际上BIOS
    47                                  ; 把引导扇区加载到0x7c00 处并把执行权交给引导程序，ss = 0x00，sp = 0xfffe。
    48                                  
    49                                  
    50 00000018 8CC8                    go:	mov	ax,cs
    51 0000001A 8ED8                    	mov	ds,ax
    52 0000001C 8EC0                    	mov	es,ax
    53 0000001E 8ED0                    	mov	ss,ax
    54 00000020 BC00FF                  	mov	sp,0xFF00		; 将堆栈指针sp 指向0x9ff00(即0x9000:0xff00)处
    55                                  ;
    56                                  ; 在 bootsect 程序块后紧跟着加载 setup模块的代码数据
    57                                  ; 注意es 已经设置好了。（在移动代码时es 已经指向目的段地址处0x9000）
    58                                  
    59                                  
    60                                  ; 【标号一】的用途是利用BIOS 中断INT 0x13 将setup 模块从磁盘第2 个扇区
    61                                  ; 开始读到0x90200 开始处，共读4 个扇区。如果读出错，则复位驱动器，并
    62                                  ; 重试，没有退路。
    63                                  ;
    64                                  ; INT 0x13 的使用方法如下：读扇区：
    65                                  ; ah = 0x02 - 读磁盘扇区到内存；al = 需要读出的扇区数量；
    66                                  ; ch = 磁道(柱面)号的低8 位； cl = 开始扇区(0-5 位)，磁道号高2 位(6-7)；
    67                                  ; dh = 磁头号； dl = 驱动器号（如果是硬盘则要置位7）；
    68                                  ; es:bx ->指向数据缓冲区； 如果出错则CF 标志置位。
    69                                  load_setup:  
    70 00000023 BA0000                  	mov	dx,0x0000		
    71 00000026 B90200                  	mov	cx,0x0002	
    72 00000029 BB0002                  	mov	bx,0x0200		
    73 0000002C B80402                  	mov	ax,0x0200+SETUPLEN	
    74 0000002F CD13                    	int	0x13			;【标号一】		
    75 00000031 0F830B00                	jnc	ok_load_setup	; 读取成功
    76 00000035 BA0000                  	mov	dx,0x0000
    77 00000038 B80000                  	mov	ax,0x0000		; 读取失败，重试
    78 0000003B CD13                    	int	0x13
    79 0000003D E9E3FF                  	jmp	load_setup
    80                                  
    81                                  ok_load_setup:
    82                                  
    83                                  ; 取磁盘驱动器的参数，特别是每道的扇区数量。
    84                                  ;
    85                                  ; INT 0x13 调用格式和返回信息如下：
    86                                  ; ah = 0x08 dl = 驱动器号（如果是硬盘则要置位7 为1）。
    87                                  ; 返回信息：
    88                                  ; 如果出错则CF 置位，并且ah = 状态码。
    89                                  ; ah = 0， al = 0， bl = 驱动器类型（AT/PS2）
    90                                  ; ch = 最大磁道号的低8 位，cl = 每磁道最大扇区数(位0-5)，最大磁道号高2 位(位6-7)
    91                                  ; dh = 最大磁头数， dl = 驱动器数量，
    92                                  ; es:di -> 软驱磁盘参数表。
    93                                  
    94 00000040 B200                    	mov	dl,0x00
    95 00000042 B80008                  	mov	ax,0x0800		
    96 00000045 CD13                    	int	0x13
    97 00000047 B500                    	mov	ch,0x00
    98                                  ;	seg cs						; 本条语句可要，也可以不要，因为本程序的所有段都在同一个段中。
    99 00000049 890E[5501]              	mov	[sectors],cx			; 保存每磁道扇区数
   100 0000004D B80090                  	mov	ax,INITSEG				; 因为上面去磁盘参数以改变es 的值，故重新赋值
   101 00000050 8EC0                    	mov	es,ax
   102                                  
   103                                  
   104 00000052 B403                    	mov	ah,0x03		
   105 00000054 30FF                    	xor	bh,bh
   106 00000056 CD10                    	int	0x10					; 读光标位置
   107                                  	
   108 00000058 B91800                  	mov	cx,24
   109 0000005B BB0700                  	mov	bx,0x0007	
   110 0000005E BD[5701]                	mov	bp,msg1
   111 00000061 B80113                  	mov	ax,0x1301		
   112 00000064 CD10                    	int	0x10					; 输出字符串
   113                                  
   114                                  ; 现在开始将system 模块加载到0x10000(64k)处
   115                                  
   116 00000066 B80010                  	mov	ax,SYSSEG
   117 00000069 8EC0                    	mov	es,ax					; es = 存放system 的段地址
   118 0000006B E83800                  	call	read_it				; 读磁盘上system 模块，es 为输入参数
   119 0000006E E8DB00                  	call	kill_motor			; 关闭驱动器马达，这样就可以知道驱动器的状态了
   120                                  
   121                                  
   122                                  ; 此后，我们检查要使用哪个根文件系统设备（简称根设备）。如果已经指定了设备(!=0)
   123                                  ; 就直接使用给定的设备。否则就需要根据BIOS 报告的每磁道扇区数来
   124                                  ; 确定到底使用/dev/PS0 (2,28) 还是 /dev/at0 (2,8)。
   125                                  ; 上面一行中两个设备文件的含义：
   126                                  ; 在Linux 中软驱的主设备号是2，次设备号 = type*4 + nr，其中 nr 为0-3 分别对应
   127                                  ; 软驱A、B、C 或D；type 是软驱的类型（2->1.2M 或7->1.44M 等）。
   128                                  ; 因为7*4 + 0 = 28，所以 /dev/PS0 (2,28)指的是1.44M A 驱动器,其设备号是0x021c
   129                                  ; 同理 /dev/at0 (2,8)指的是1.2M A 驱动器，其设备号是0x0208。
   130                                  
   131                                  ;	seg cs
   132 00000071 A1[FC01]                	mov	ax,[root_dev]		; 去508,509字节处的根设备号并判断是否已被定义
   133 00000074 3D0000                  	cmp	ax,0
   134 00000077 0F851D00                	jne	root_defined
   135                                  ;	seg cs
   136                                  ; 取上面保存的每磁道扇区数。如果sectors=15
   137                                  ; 则说明是1.2Mb 的驱动器；如果sectors=18，则说明是
   138                                  ; 1.44Mb 软驱。因为是可引导的驱动器，所以肯定是A 驱。
   139 0000007B 8B1E[5501]              	mov	bx,[sectors]
   140 0000007F B80802                  	mov	ax,0x0208		; /dev/ps0 - 1.2Mb
   141 00000082 81FB0F00                	cmp	bx,15
   142 00000086 0F840E00                	je	root_defined	; 如果等于，则ax 中就是引导驱动器的设备号
   143 0000008A B81C02                  	mov	ax,0x021c		; /dev/PS0 - 1.44Mb
   144 0000008D 81FB1200                	cmp	bx,18
   145 00000091 0F840300                	je	root_defined	; 如果都不一样，则死循环（死机)
   146                                  undef_root:
   147 00000095 E9FDFF                  	jmp undef_root		
   148                                  root_defined:
   149                                  ;	seg cs
   150 00000098 A3[FC01]                	mov	[root_dev],ax	; 将检查过的设备号保存起来
   151                                  
   152                                  ;
   153                                  ; 到此，所有程序都加载完毕，我们就跳转到被加载在bootsect 后面的setup 程序去。
   154                                  
   155 0000009B EA00002090              	jmp	SETUPSEG:0
   156                                  
   157                                  ; 该子程序将系统模块加载到内存地址0x10000 处，并确定没有跨越64KB 的内存
   158                                  ; 边界。我们试图尽快地进行加载，只要可能，就每次加载整条磁道的数据。
   159                                  ;
   160                                  ; 输入：es C 开始内存地址段值（通常是0x1000）
   161                                  ;
   162 000000A0 0500                    sread:	dw 1+SETUPLEN	; 当前磁道中已读的扇区数
   163 000000A2 0000                    head:	dw 0			; 当前磁头号
   164 000000A4 0000                    track:	dw 0			; 当前磁道号
   165                                  
   166                                  read_it:
   167                                  ; 测试输入的段值。必须位于内存地址64KB 边界处，否则进入死循环。清bx 寄存器，
   168                                  ; 用于表示当前段内存放数据的开始位置。
   169 000000A6 8CC0                    	mov ax,es
   170 000000A8 A9FF0F                  	test ax,0x0fff
   171 000000AB 0F85FCFF                die:	jne die			; es 值必须位于64KB 地址边界
   172 000000AF 31DB                    	xor bx,bx			; bx 为段内偏移位置
   173                                  rp_read:
   174 000000B1 8CC0                    	mov ax,es
   175 000000B3 3D0040                  	cmp ax,ENDSEG		; 是否已经加载了全部数据？
   176 000000B6 0F820100                	jb ok1_read
   177 000000BA C3                      	ret
   178                                  ok1_read:
   179                                  ; 计算和验证当前磁道需要读取的扇区数，放在ax 寄存器中。
   180                                  ; 根据当前磁道还未读取的扇区数以及段内数据字节开始偏移位置，计算如果全部读取这些未读扇区，所
   181                                  ; 读总字节数是否会超过64KB 段长度的限制。若会超过，则根据此次最多能读入的字节数(64KB C 段内
   182                                  ; 偏移位置)，反算出此次需要读取的扇区数。
   183 000000BB A1[5501]                	mov ax,[sectors]	; 取每磁道扇区数
   184 000000BE 2B06[A000]              	sub ax,[sread]		; 减去当前磁道已读扇区数
   185 000000C2 89C1                    	mov cx,ax
   186 000000C4 C1E109                  	shl cx,9			; cx = cx * 512 字节。
   187 000000C7 01D9                    	add cx,bx			; cx = cx + 段内当前偏移值(bx)
   188 000000C9 0F830B00                	jnc ok2_read		; 若没有超过64KB 字节，则跳转至ok2_read 处执行
   189 000000CD 0F840700                	je ok2_read
   190 000000D1 31C0                    	xor ax,ax			; 若加上此次将读磁道上所有未读扇区时会超过64KB，则计算
   191 000000D3 29D8                    	sub ax,bx			; 此时最多能读入的字节数(64KB C 段内读偏移位置)，再转换
   192 000000D5 C1E809                  	shr ax,9			; 成需要读取的扇区数
   193                                  ok2_read:
   194 000000D8 E83A00                  	call read_track
   195 000000DB 89C1                    	mov cx,ax			; cx = 该次操作已读取的扇区数
   196 000000DD 0306[A000]              	add ax,[sread]		; 当前磁道上已经读取的扇区数
   197                                  ;	seg cs
   198 000000E1 3B06[5501]              	cmp ax,[sectors]
   199 000000E5 0F851400                	jne ok3_read		; 如果当前磁道上的还有扇区未读，则跳转到ok3_read 处
   200 000000E9 B80100                  	mov ax,1
   201 000000EC 2B06[A200]              	sub ax,[head]		
   202 000000F0 0F850400                	jne ok4_read		; 如果是0 磁头，则再去读1 磁头面上的扇区数据
   203 000000F4 FF06[A400]              	inc word [track]	; 否则去读下一磁道
   204                                  ok4_read:
   205 000000F8 A3[A200]                	mov [head],ax		; 保存当前磁头号
   206 000000FB 31C0                    	xor ax,ax			; 清当前磁道已读扇区数
   207                                  ok3_read:
   208 000000FD A3[A000]                	mov [sread],ax		; 保存当前磁道已读扇区数
   209 00000100 C1E109                  	shl cx,9			; 上次已读扇区数*512 字节
   210 00000103 01CB                    	add bx,cx			; 调整当前段内数据开始位置
   211 00000105 0F83A8FF                	jnc rp_read			; 若小于64KB 边界值，则跳转到rp_read处，继续读数据。! 否则调整当前段，为读下一段数据作准备。
   212 00000109 8CC0                    	mov ax,es
   213 0000010B 050010                  	add ax,0x1000		; 将段基址调整为指向下一个64KB 段内存
   214 0000010E 8EC0                    	mov es,ax
   215 00000110 31DB                    	xor bx,bx
   216 00000112 E99CFF                  	jmp rp_read			; 跳转至rp_read处，继续读数据
   217                                  
   218                                  ; 读当前磁道上指定开始扇区和需读扇区数的数据到es:bx 开始处。
   219                                  ; int 0x13，ah=2 的说明。
   220                                  ; al C 需读扇区数；es:bx C 缓冲区开始位置。
   221                                  
   222                                  read_track:
   223 00000115 50                      	push ax
   224 00000116 53                      	push bx
   225 00000117 51                      	push cx
   226 00000118 52                      	push dx
   227 00000119 8B16[A400]              	mov dx,[track]		; 取当前磁道号
   228 0000011D 8B0E[A000]              	mov cx,[sread]		; 取当前磁道上已读扇区数
   229 00000121 41                      	inc cx				; cl = 开始读扇区
   230 00000122 88D5                    	mov ch,dl			; ch = 当前磁道号
   231 00000124 8B16[A200]              	mov dx,[head]		; 取当前磁头号
   232 00000128 88D6                    	mov dh,dl			; dh = 磁头号
   233 0000012A B200                    	mov dl,0			; dl = 驱动器号(为0 表示当前驱动器)
   234 0000012C 81E20001                	and dx,0x0100		; 磁头号不大于1
   235 00000130 B402                    	mov ah,2			; ah = 2，读磁盘扇区功能号
   236 00000132 CD13                    	int 0x13
   237 00000134 0F820500                	jc bad_rt			; 若出错，则跳转至bad_rt
   238 00000138 5A                      	pop dx
   239 00000139 59                      	pop cx
   240 0000013A 5B                      	pop bx
   241 0000013B 58                      	pop ax
   242 0000013C C3                      	ret
   243                                  ; 执行驱动器复位操作
   244 0000013D B80000                  bad_rt:	mov ax,0
   245 00000140 BA0000                  	mov dx,0
   246 00000143 CD13                    	int 0x13
   247 00000145 5A                      	pop dx
   248 00000146 59                      	pop cx
   249 00000147 5B                      	pop bx
   250 00000148 58                      	pop ax
   251 00000149 E9C9FF                  	jmp read_track
   252                                  
   253                                  ; 这个子程序用于关闭软驱的马达，这样我们进入内核后它处于已知状态，以后也就无须担心它了
   254                                  kill_motor:
   255 0000014C 52                      	push dx
   256 0000014D BAF203                  	mov dx,0x3f2
   257 00000150 B000                    	mov al,0
   258 00000152 EF                      	out dx,ax
   259 00000153 5A                      	pop dx
   260 00000154 C3                      	ret
   261                                  
   262                                  sectors:
   263 00000155 0000                    	dw 0
   264                                  
   265                                  msg1:
   266 00000157 0D0A                    	db 13,10
   267 00000159 4C6F6164696E672073-     	db "Loading system ..."
   268 00000162 797374656D202E2E2E 
   269 0000016B 0D0A0D0A                	db 13,10,13,10
   270                                  
   271 0000016F 00<rept>                times 	508-($-$$)	db	0	
   272                                  root_dev:
   273 000001FC 0103                    	dw ROOT_DEV
   274                                  boot_flag:
   275 000001FE 55AA                    	dw 0xAA55
   276                                  
